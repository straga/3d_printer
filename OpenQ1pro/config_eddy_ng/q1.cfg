# DO NOT EDIT THIS FILE.
# This file is part of a git repository, your changes may prevent updates

[include gcode_macro.cfg]


[mcu]
serial: /dev/ttyS2
restart_method: command

[mcu U_1]
serial: /dev/ttyS0
restart_method: command

[mcu eddy]
serial: /dev/serial/by-id/usb-Klipper_rp2040_5044340310215E1C-if00  # Поменять на ваш ID устройства
restart_method: command


[respond]
default_type: echo

[resonance_tester]
accel_per_hz: 150
max_smoothing:0.5

[duplicate_pin_override]
pins:
     gpio21 ,U_1:PC3

[bed_screws]
screw1:10,10
screw1_name: Front left
screw2: 230,10
screw2_name: Front right
screw3: 125,240
screw3_name: Back right
probe_height: 0.2
horizontal_move_z: 10

# [screws_tilt_adjust]
# screw1:10,10
# screw1_name: Front left
# screw2: 220,10
# screw2_name: Front right
# screw3: 125,230
# screw3_name: Back right
# screw_thread: CW-M4

[screws_tilt_adjust]
screw1:0,17
screw1_name: Front left
screw2: 193,17
screw2_name: Front right
screw3: 91,237
screw3_name: Back right
screw_thread: CW-M4 

[force_move]
enable_force_move : True


[hall_filament_width_sensor]
adc1: gpio27
adc2: gpio28
cal_dia1: 1.48 # calibration data from author's unit
cal_dia2: 1.97 # this hall effect filament sensor is kinda useless as width sensor actually,
raw_dia1: 13422 # because the inlet is not mounted rigidly, the filament will pivot and make the reading really high when bend to the left
raw_dia2: 14765
default_nominal_filament_diameter: 1.75
max_difference: 0
measurement_delay: 102
enable: false
measurement_interval: 10
logging: False
min_diameter: 1.0
max_diameter: 2.7
use_current_dia_while_delay: False
pause_on_runout: True
runout_gcode:
            PAUSE
            RESET_FILAMENT_WIDTH_SENSOR
            M118 Filament run out
event_delay: 3.0
pause_delay: 0.5

[extruder]
step_pin:gpio5
dir_pin:gpio4
enable_pin:!gpio10
rotation_distance: 53.7  #22.6789511    #Bondtech 5mm Drive Gears
gear_ratio: 1517:170
microsteps: 16
full_steps_per_rotation: 200    #200 for 1.8 degree, 400 for 0.9 degree
nozzle_diameter: 0.400
filament_diameter: 1.75
min_temp: 0
max_temp: 360
min_extrude_temp: 175
smooth_time: 0.000001
heater_pin:gpio24
sensor_type:MAX6675
sensor_pin:gpio17
spi_software_sclk_pin:gpio18
spi_software_mosi_pin:gpio19
spi_software_miso_pin:gpio16
spi_speed: 100000
max_power: 1
control : pid
pid_Kp=33.555
pid_Ki=4.76
pid_Kd=59.141
pressure_advance: 0.032
pressure_advance_smooth_time: 0.03
max_extrude_cross_section:500
instantaneous_corner_velocity: 10.000
max_extrude_only_distance: 1000.0
max_extrude_only_velocity:5000
max_extrude_only_accel:2000
step_pulse_duration:0.000002

[tmc2209 extruder]
uart_pin:gpio6
interpolate: True
run_current: 0.714
stealthchop_threshold: 0

[adxl345]
cs_pin:gpio13
spi_software_sclk_pin:gpio14
spi_software_mosi_pin:gpio15
spi_software_miso_pin:gpio12
axes_map: -x, z, -y

[printer]
kinematics:corexy
max_velocity: 600
max_accel: 20000
max_z_velocity: 10
max_z_accel: 500
square_corner_velocity: 8

[stepper_x]
step_pin:U_1:PB4
dir_pin:!U_1:PB3
enable_pin:!U_1:PB5
microsteps:16
rotation_distance: 39.88
full_steps_per_rotation:200  #set to 400 for 0.9 degree stepper
endstop_pin:tmc2240_stepper_x:virtual_endstop
position_min: -5.5
position_endstop: -5.5
position_max:245
homing_speed:50
homing_retract_dist:0
homing_positive_dir:False
step_pulse_duration:0.0000001

[stepper_y]
step_pin:U_1:PC14
dir_pin:!U_1:PC13
enable_pin:!U_1:PC15
microsteps: 16
rotation_distance: 39.88
full_steps_per_rotation:200  #set to 400 for 0.9 degree stepper
endstop_pin:tmc2240_stepper_y:virtual_endstop
position_min: -4.5
position_endstop: -4.5
position_max: 258
homing_speed:50
homing_retract_dist:0
homing_positive_dir:False
step_pulse_duration:0.0000001

# [probe_eddy_current btt_eddy]
# For all Eddy (USB/Duo/Coil)
[probe_eddy_ng btt_eddy]
sensor_type: ldc1612
# z_offset: 2.5
#i2c_address:
i2c_mcu: eddy  # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the MCU you have used.
i2c_bus: i2c0f # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the I2C bus you have used.
# Measure the offsets below using the method described here: https://www.klipper3d.org/Probe_Calibrate.html#calibrating-probe-x-and-y-offsets
# For a standard Voron stealthburner X carriage mount there should be no need to change the defaults below.
x_offset: 36
y_offset: 7

samples_per_second: 500 # 250 by default

# This section is only relevant for Eddy USB. Comment it out for Eddy Coil.

[temperature_probe btt_eddy]
sensor_type: Generic 3950
sensor_pin: eddy:gpio26
horizontal_move_z: 2

[bed_mesh] 
horizontal_move_z: 2
speed: 200
# For the mesh dimensions below, the coordinates need to be reachable by the center of the probe. To calculate coordinates that will work, use the formula below:
# mesh x min = position_min_x + greater_of (15mm or x_offset) <--- in this term, only consider the x offset if it is positive, ignore if negative.
# mesh y min = position_min_y + greater_of (15mm or y_offset) <--- in this term, only consider the y offset if it is positive, ignore if negative.
# mesh x max = position_max_x - greater_of (15mm or |x_offset|) <--- in this term, only consider the x offset if it is negative, ignore if positive.
# mesh y max = position_max_y - greater_of (15mm or |y_offset|) <--- in this term, only consider the y offset if it is negative, ignore if positive.
# Example: Consider that you have a 300 x 300 bed with the max x and y positions being 300 and the min being 0. Your probe offsets are -20 for X and 10 for Y
# For mesh x min we ignore the x offset term because it is negative. Therefore mesh x min = 15
# For mesh y min we do not ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y min = 15
# For mesh x max we do not ignore the x offset term because it is negative. It is also greater than 15. Therefore mesh x max = 280
# For mesh y max we ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y max = 285
# The final result would be mesh_min: 15, 15 mesh_max: 280, 285
# mesh_min: 20, 15  # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
# mesh_max: 230, 230 # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.

mesh_min: 56, 22   # 20+36, 15+7
mesh_max: 194, 223 # 230-36, 230-7

probe_count: 11, 11
algorithm: bicubic
#scan_overshoot: 8  #uncomment this section if you still have room left over on the X axis for some scan overshoot to product smoother movements and more accurate scanning. Uncommenting this should be fine if you are using a standard voron mount.

# # Uncomment this if you are using Eddy as the probe AND the homing endstop
# [safe_z_home]
# home_xy_position: 150, 150 # Choose an X,Y position that is in the center of your bed. For a 300x300 machine that will be 150, 150. Use the same principle to calculate your bed center.
# z_hop: 10
# z_hop_speed: 25
# speed: 200

[stepper_z]
step_pin:U_1:PC10
dir_pin:U_1:PA15
enable_pin:!U_1:PC11
microsteps: 128
rotation_distance: 4
full_steps_per_rotation: 200
endstop_pin: probe:z_virtual_endstop  # Используем Eddy как виртуальный эндстоп
position_max: 248
position_min: -4
homing_speed: 8
second_homing_speed: 10
homing_retract_dist: 5.0
homing_positive_dir:false

[stepper_z1]
step_pin:U_1:PB1
dir_pin:U_1:PB6
enable_pin:!U_1:PB0
microsteps: 128
rotation_distance: 4
full_steps_per_rotation: 200
step_pulse_duration:0.0000001

[z_tilt]
z_positions:
    -59,125
    307.5,125

points:
    0,117 # 0 - 36 по X, 125 -  7 по Y
    186,117 # 215 - 36 по X, 125-7 по Y

speed: 150
horizontal_move_z: 5
retries: 2
retry_tolerance: 0.05

[tmc2240 stepper_y]
cs_pin: U_1:PB9
spi_software_sclk_pin: U_1:PA5
spi_software_mosi_pin: U_1:PA7
spi_software_miso_pin: U_1:PA6
spi_speed: 200000
run_current: 1.07
interpolate: true
stealthchop_threshold: 0
coolstep_threshold: 15
diag0_pin: !U_1:PC0
driver_SGT: 1

[tmc2240 stepper_x]
cs_pin: U_1:PD2
spi_software_sclk_pin: U_1:PA5
spi_software_mosi_pin: U_1:PA7
spi_software_miso_pin: U_1:PA6
spi_speed: 200000
run_current: 1.07
interpolate: true
stealthchop_threshold: 0
coolstep_threshold: 15
diag0_pin: !U_1:PB8
driver_SGT: 1

[tmc2209 stepper_z]
uart_pin:U_1: PC5
run_current: 0.6
interpolate: True
stealthchop_threshold: 9999999999

[tmc2209 stepper_z1]
uart_pin:U_1: PB7
run_current: 0.6
interpolate: True
stealthchop_threshold: 9999999999



[heater_bed]
heater_pin: U_1:PB10
sensor_type:NTC 100K MGB18-104F39050L32
sensor_pin:U_1: PA0
max_power: 1.0
control = pid
pid_Kp=63.418
pid_Ki=1.342
pid_Kd=749.125
min_temp: -60
max_temp: 125

[heater_generic chamber]
heater_pin:U_1:PC8
max_power:1.0
sensor_type:NTC 100K MGB18-104F39050L32
sensor_pin:U_1:PA1
control = pid
#max_delta: 1.0
pid_Kp=63.418
pid_Ki=1.342
pid_Kd=749.125

min_temp:-100
max_temp:62

[verify_heater chamber]
max_error: 300
check_gain_time:480
hysteresis: 5
heating_gain: 1

[verify_heater extruder]
max_error: 120
check_gain_time:20
hysteresis: 5
heating_gain: 1

[verify_heater heater_bed]
max_error: 200
check_gain_time:60
hysteresis: 5
heating_gain: 1

[fan_generic auxiliary_cooling_fan]
pin: U_1:PA8
shutdown_speed: 0.0
cycle_time: 0.0100
hardware_pwm: false
kick_start_time: 0.100
off_below: 0.0

# [fan_generic chamber_circulation_fan]
# pin:U_1:PC9
# shutdown_speed: 0.0
# cycle_time: 0.100
# hardware_pwm: false
# kick_start_time: 0.100
# off_below: 0.0

[temperature_fan board_fan_big]
pin:U_1:PC9
max_power: 1.0
shutdown_speed: 0.0
kick_start_time: 0.5
off_below: 0.19
control: watermark
sensor_type: temperature_host
min_temp: 0
max_temp: 100
target_temp: 55.0
max_speed: 0.6
min_speed: 0.2
control: pid
pid_Kp: 2.0
pid_Ki: 5.0
pid_Kd: 0.5
pid_deriv_time: 2.0




[heater_fan chamber_fan]
pin:U_1:PA4
max_power: 1.0
shutdown_speed: 0
kick_start_time: 0.5
heater: chamber
heater_temp: 35
fan_speed: 1.0
off_below: 0

[heater_fan hotend_fan]
pin:gpio25
max_power: 1.0
shutdown_speed:1.0
kick_start_time: 0.5
heater: extruder
heater_temp: 65.0
fan_speed: 1.0
off_below: 0

[heater_fan hotend_fan2]
pin:gpio11
max_power: 1.0
shutdown_speed:1.0
kick_start_time: 0.5
heater: extruder
heater_temp: 65.0
fan_speed: 1.0
off_below: 0

[fan_generic cooling_fan]
pin:gpio2
max_power: 1.0
shutdown_speed: 0
cycle_time: 0.0100
hardware_pwm: false
kick_start_time: 0.100
off_below: 0.0

[temperature_sensor host]
sensor_type: temperature_host

[temperature_sensor toolhead_board_mcu]
sensor_type: temperature_mcu

[temperature_sensor mainboard_mcu]
sensor_type: temperature_mcu
sensor_mcu: U_1

[temperature_sensor btt_eddy_mcu]
sensor_type: temperature_mcu # Sets the type of sensor for Klipper to read
sensor_mcu: eddy # Sets the MCU of the eddy probe tempereature sensor
min_temp: 10 # Sets the minimum tempereature for eddys tempereature sensor to operate
max_temp: 100 # Sets the maximum tempereature for eddys tempereature sensor to operate

# [fan_generic board_fan]
# pin:U_1:PC4
# max_power:1.0
# shutdown_speed:1.0

[temperature_fan board_fan_small]
pin:U_1:PC4
max_power: 1.0
shutdown_speed: 0.0
kick_start_time: 0.5
off_below: 0.00
control: watermark
sensor_type: temperature_host
min_temp: 0
max_temp: 100
target_temp: 55.0
max_speed: 0.6
min_speed: 0.0
control: pid
pid_Kp: 2.0
pid_Ki: 5.0
pid_Kd: 0.5
pid_deriv_time: 2.0


# [delayed_gcode board_fan_control]
# ;description: 2-point linear fan curve control with hysteresis at the off/min state, basically default "watermark" control, but can go to 100% when printed in a heated chamber and extra cooling is needed, or just bang-bang with 20% when idle.
# initial_duration: 1.
# gcode:
#     {% set t_off = 60 %} ; fan will turn off after dropping below this temperature at min_speed
#     {% set t_on = 70 %} ; fan will turn on at "min_speed" after rising above this temperature
#     {% set t_max = 80 %} ; fan is max at this temperature
#     {% set min_speed = 0.2 %} ; if fan speed should be between 0 and min_speed, min_speed will be used

#     {% set temp_x = printer['tmc2240 stepper_x'].temperature|default(0)|float %}
#     {% set temp_y = printer['tmc2240 stepper_y'].temperature|default(0)|float %}
#     {% set max_temp = ([printer['temperature_sensor host'].temperature, printer['temperature_sensor mainboard_mcu'].temperature, temp_x, temp_y ] | sort)[-1] %}
#     ; max detected temperature on the electronics bay
#     ;M118 Max temp electronics {max_temp} ;for debugging
#     {% if ( max_temp >= t_on ) %}
#         {% set fan_speed = ([( [max_temp - t_on, t_max - t_on] | min), 0] | max) / (t_max - t_on) * (1.0 - min_speed) + min_speed %}
#         {% if (fan_speed > 0) and (fan_speed < min_speed) %}
#             {% set fan_speed = min_speed %}
#         {% endif %}
#         SET_FAN_SPEED FAN=board_fan SPEED={fan_speed}
#     {% elif max_temp < t_off %}
#         SET_FAN_SPEED FAN=board_fan SPEED=0
#     {% elif printer['fan_generic board_fan'].speed > 0 %}
#         SET_FAN_SPEED FAN=board_fan SPEED={min_speed}
#     {% endif %}

#     UPDATE_DELAYED_GCODE ID=board_fan_control DURATION=1

[output_pin caselight]
pin: U_1:PC7
pwm: false
shutdown_value:1
value:1

[output_pin beeper]
pin:U_1: PA2
pwm: false
shutdown_value:0
value:0

[output_pin sound]
pin: U_1:PA13
value:0

[output_pin bed_sensor]
pin: !U_1:PA14
value:0

# [auto_z_offset]
# pin: U_1:PC1
# z_offset: -0.07
# speed: 10
# probe_accel: 50
# samples: 5
# samples_result: average
# samples_tolerance: 0.05
# samples_tolerance_retries: 5
# prepare_gcode:
#     SET_PIN PIN=bed_sensor VALUE=0
#     G91
#     {% set i = 4 %}
#     {% for iteration in range(i|int) %}
#         G1 Z1 F900
#         G1 Z-1 F900
#     {% endfor %}
#     G90
#     SET_PIN PIN=bed_sensor VALUE=1

# [bed_mesh]
# speed: 150
# mesh_min: 20,15
# mesh_max: 230,230
# probe_count: 8,8
# algorithm: bicubic
# adaptive_margin: 5

[filament_switch_sensor tangle]
pause_on_runout: True
runout_gcode:
            PAUSE
event_delay: 3.0
pause_delay: 0.5
switch_pin:U_1:PC3

[resonance_tester]
accel_chip: adxl345
probe_points:
   120, 120, 10

[gcode_arcs]
resolution: 1.0

[pause_resume]

[display_status]

[exclude_object]

[shaketune]
result_folder: ~/printer_data/config/ShakeTune_results #The folder where the results will be stored. It will be created if it doesn't exist.
number_of_results_to_keep: 3 #The number of results to keep in the result_folder. The oldest results will be automatically deleted after each runs.
keep_raw_data: False #If True, the raw CSV files will be kept in the result_folder alongside the PNG graphs. If False, they will be deleted and only the graphs will be kept.
show_macros_in_webui: True #Mainsail and Fluidd doesn't create buttons for "system" macros that are not in the printer.cfg file. If you want to see the macros in the webui, set this to True.
timeout: 300 #The maximum time in seconds to let Shake&Tune process the CSV files and generate the graphs.


[idle_timeout]
gcode:
    TURN_OFF_HEATERS
    M84
timeout: 600



